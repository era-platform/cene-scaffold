\= chops.cene (part of Cene Scaffold)
\= Copyright 2016 Ross Angle. Released under the MIT License.

\= TODO: See if we should factor this file out into a separate
\= codebase.


(defn regex-or a b
  (regex-if a (regex-empty/nil) b))

(defn regex-seq a b
  (regex-if a b /regex-give-up/nil))

(defn regex-not regex
  (regex-if regex (regex-give-up/nil) (regex-empty/nil)))

(defn regex-lookahead regex
  (regex-not/regex-not regex))

\= TODO: See if we'll use these.
(defn unicode-scalar string
  (string-get-unicode-scalar string /int-zero/nil))
(defn regex-range a b
  (regex-one-in-range unicode-scalar.a unicode-scalar.b))

(defn regex-match-later regex string start then
  (optimize-regex-later regex /fn optimized-regex
  /optimized-regex-match-later
    optimized-regex string start string-length.string then))


(defn string-cut-both-later string i then
  (string-cut-later string (int-zero/nil) i /fn before
  /string-cut-later string i string-length.string /fn after
  /c then before after))


(defn istring-first-string istring
  (case istring
    istring-nil string string
    istring-cons prefix interpolation rest prefix
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(defn istring-replace-first-string istring new-string
  (case istring
    
    istring-nil string istring-nil.new-string
    
    istring-cons prefix interpolation rest
    (istring-cons new-string interpolation rest)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))


(defn int-plus a b
  (call-fuse (fuse-int-by-plus/nil) a b))


(def-struct parse-chops-result closed-stack chops opened-stack)

\= This parses an istring to match its `[` and `]` brackets. It
\= asynchronously results in a list (from left to right) of nested
\= interpolated strings that have been closed by unmatched `]`,
\= another nested interpolated string, and a list (from left to right)
\= of nested interpolated strings that have been opened by unmatched
\= `[`. Interpolations in the original string are wrapped in
\= `(foreign ...)` so that they're distinguishable from bracket
\= nesting.
\=
(defn parse-chops-later istring then
  (let string istring-first-string.istring
  /regex-match-later
    (regex-until (regex-one/nil)
    /regex-lookahead/regex-one-in-string str.\;qq[\<`\>])
    string
    (int-zero/nil)
  /fn regex-result
  /case regex-result
    
    regex-result-passed-end
    (cast istring istring-cons prefix interpolation rest
      (c then /parse-chops-result (list) istring (list))
    /parse-chops-later rest /fn parse-chops-result
    /c then
    /cast parse-chops-result
      parse-chops-result closed-stack chops opened-stack
      err.\;qq[Internal error]
    /cast closed-stack cons leftmost-closed rest-closed
      (parse-chops-result
        (list)
        (istring-cons prefix foreign.interpolation chops)
        opened-stack)
    /parse-chops-result
      (cons
        (istring-cons prefix foreign.interpolation leftmost-closed)
        rest-closed)
      chops
      opened-stack)
    
    regex-result-matched stop
    (string-cut-both-later string stop /fn before after
    /string-cut-both-later after (int-one/nil) /fn during after
    /parse-chops-later (istring-replace-first-string istring after)
    /fn parse-chops-result
    /c then
    /cast parse-chops-result
      parse-chops-result closed-stack chops opened-stack
      err.\;qq[Internal error]
    /case (string-metacompare during str.\;qq[\>]) nil
      (parse-chops-result
        (cons istring-nil.before closed-stack)
        chops
        opened-stack)
    /cast closed-stack cons leftmost-closed rest-closed
      (parse-chops-result
        (list)
        istring-nil.before
        (cons chops opened-stack))
    /cast rest-closed cons leftmost-closed-2 rest-closed
      (parse-chops-result
        (list)
        (istring-cons before leftmost-closed chops)
        opened-stack)
    /parse-chops-result
      (cons (istring-cons before leftmost-closed leftmost-closed-2)
        rest-closed)
      chops
      opened-stack)
    
    regex-result-failed
    err.\;qq[Internal error]
    
    err.\;qq[Internal error]))

(def-struct chops-macro-call macro-name-string body-istring)

\= This parses an interpolated string to produce a macro call
\= consisting of a string as the macro name and an interpolated string
\= as the macro body. The macro name is obtained by finding zero or
\= more characters at the start of the string other than space, tab,
\= carriage return, and newline. The macro body is obtained by
\= removing the macro name and left-trimming the remainder of its
\= space, tab, carriage return, and newline characters.
\=
(defn parse-chops-macro-call-later istring then
  (let string istring-first-string.istring
  /let regex-whitespace (regex-one-in-string str.\;qq[\s`\t`\r`\n])
  /regex-match-later
    (regex-until (regex-one/nil) /regex-lookahead regex-whitespace)
    string
    (int-zero/nil)
  /fn regex-result
  /case regex-result
    
    regex-result-passed-end
    (case istring
      
      istring-nil string
      (c then /chops-macro-call string /istring-nil str.\;qq[])
      
      istring-cons prefix interpolation rest
      (c then /chops-macro-call prefix
      /istring-cons str.\;qq[] interpolation rest)
      
      err.\;qq[Internal error])
    
    regex-result-matched stop
    (string-cut-both-later string stop /fn before after
    /regex-match-later
      (regex-until (regex-one/nil) /regex-not regex-whitespace)
      after
      (int-zero/nil)
    /fn regex-result
    /cast regex-result regex-result-matched next-stop
      err.\;qq[Internal error]
    /string-cut-later after next-stop string-length.after /fn after
    /c then /chops-macro-call before
    /istring-replace-first-string istring after)
    
    regex-result-failed
    err.\;qq[Internal error]
    
    err.\;qq[Internal error]))

(defn string-ltrim-later string regex then
  (regex-match-later (regex-while regex /regex-empty/nil) string
    (int-zero/nil)
  /fn regex-result
  /case regex-result
    
    regex-result-matched stop
    (string-cut-later string stop string-length.string then)
    
    regex-result-passed-end
    (c-later then str.\;qq[])
    
    regex-result-failed
    err.\;qq[Internal error]
    
    err.\;qq[Internal error]))

(defn istring-ltrim-later istring regex then
  (string-ltrim-later istring-first-string.istring regex /fn string
  /c then /istring-replace-first-string istring string))

(defn string-rtrim-later string regex then
  (let get-next-stop-later
    (fn i regex then
      (regex-match-later regex string i /fn regex-result
      /case regex-result
        
        regex-result-matched stop
        (c then stop)
        
        regex-result-passed-end
        (c then /string-length string)
        
        regex-result-failed
        err.\;qq[Internal error]
        
        err.\;qq[Internal error]))
  /let loop
    (fix/fn loop i
      (c get-next-stop-later i
        (regex-until (regex-one/nil) /regex-lookahead regex)
      /fn i2
      /c get-next-stop-later i2 (regex-while regex /regex-empty/nil)
      /fn i3
      /case (int-compare i3 /string-length string) nil
        (string-cut-later string (int-zero/nil) i2 then)
      /c loop i3))
  /c loop /int-zero/nil))

(defn istring-rtrim-later istring regex then
  (case istring
    
    istring-nil string
    (string-rtrim-later string regex /fn string
    /c then /istring-nil string)
    
    istring-cons prefix interpolation rest
    (istring-rtrim-later rest regex /fn rest
    /c then /istring-cons prefix interpolation rest)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(defn istring-trim-later istring regex then
  (istring-ltrim-later istring regex /fn istring
  /istring-rtrim-later istring regex then))

(defn string-split-later string regex then
  (let loop
    (fix/fn loop rev-results i
      (regex-match-later
        (regex-until (regex-one/nil) /regex-lookahead regex)
        string
        i
      /fn regex-result
      /case regex-result
        
        regex-result-matched stop
        (string-cut-later string i stop /fn result
        /regex-match-later regex string stop /fn regex-result
        /cast regex-result regex-result-matched stop
          err.\;qq[Internal error]
        /c loop (cons result rev-results) stop)
        
        regex-result-passed-end
        (string-cut-later string i string-length.string /fn result
        /c then /rev/cons result rev-results)
        
        regex-result-failed
        err.\;qq[Internal error]
        
        err.\;qq[Internal error]))
  /c loop (list) /int-zero/nil))

(defn istring-split-later istring regex then
  (case istring
    
    istring-nil string
    (string-split-later string regex /fn strings
    /c then /map strings /fn string istring-nil.string)
    
    istring-cons prefix interpolation rest
    (string-split-later prefix regex /fn prefix-strings
    /istring-split-later rest regex /fn rest-istrings
    /cast rev.prefix-strings
      cons last-prefix-string rev-prefix-strings
      err.\;qq[Internal error]
    /cast rest-istrings cons first-rest-istring rest-istrings
      err.\;qq[Internal error]
    /c then /rev-append
      (map rev-prefix-strings /fn string istring-nil.string)
    /cons
      (istring-cons
        last-prefix-string interpolation first-rest-istring)
      rest-istrings)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(defn chops-trim-later istring then
  (istring-trim-later istring
    (regex-one-in-string str.\;qq[\s`\t`\r`\n])
    then))

(defn chops-split-and-trim-later istring then
  (istring-split-later istring (regex-from-string str.\;qq[|])
  /fn istrings
  /map-later istrings (chops-trim-later) then))

(def-struct chops-macro-occurrence name)

(def-struct chops-macro-ns)

(defn procure-sub-ns name ns
  (proj1 yep /table-get name
  /procure-sub-ns-table (table-shadow name (yep/nil) /table-empty/nil)
    ns))

(defn getdef-get mode getdef
  (cast getdef getdef get def
    err.\;qq[Expected a getdef that was a getdef]
  /c get mode))

(defn getdef-def-val getdef val
  (cast getdef getdef get def
    err.\;qq[Expected a getdef that was a getdef]
  /definer-define def (dex-give-up/nil) val))

(defn chops-macro-getdef macro-name-string scope
  (cast scope scope unique-ns def-ns qualify
    err.\;qq[Expected a scope that was a scope]
  /procure-contributed-element-getdef
    (procure-sub-ns
      (c qualify
      /name-of/dexable
        (dex-struct chops-macro-occurrence /dex-name/nil)
      /chops-macro-occurrence
      /name-of/dexable (dex-string/nil) macro-name-string)
    /procure-sub-ns
      (name-of/dexable dex-struct.chops-macro-ns /chops-macro-ns)
      def-ns)
    (name-of/dexable (dex-string/nil) str.\;qq[val])))

(defn chops-macroexpand-later scope istring then
  (parse-chops-macro-call-later istring /fn call
  /cast call chops-macro-call macro body
    err.\;qq[Internal error]
  /get-mode/fn mode
  /c (getdef-get mode /chops-macro-getdef macro scope)
    scope body then))

(def-macro def-chops-macro
  home-scope caller-scope my-stx-details args then
  
  (cast caller-scope
    scope caller-unique-ns caller-def-ns caller-qualify
    err.\;qq[Internal error]
  /join-effects procure-claim.caller-unique-ns
  /let subscope
    (fn string
      (scope (ns-get string caller-unique-ns) caller-def-ns
        caller-qualify))
  /cast args cons macro-name fn-body
    err.\;qq[Called def-chops-macro with fewer than one argument]
  \= TODO: Support more than just string names here.
  /cast macro-name stx - macro-name
    err.\;qq[
      Called def-chops-macro with a macro name that wasn't a stx]
  /cast macro-name istring-nil macro-name-string
    err.\;qq[Called def-chops-macro with a non-string macro name]
  /basic-nil-macro
    home-scope (c subscope str.body) my-stx-details then
  /fn unique-ns s mac
  /compile-expression-later (c subscope str.compile-fn)
    (c s /c mac str.fn fn-body)
  /fn func
  /get-mode/fn mode
  /getdef-def-val (chops-macro-getdef macro-name-string caller-scope)
  /c (eval-cexpr mode func) /c subscope str.home))


(defn str-^-qq-- s contents
  (c s /list (c s /istring-nil str.^)
  /c s /list (c s /istring-nil str.qq)
  /c s /list (c s /istring-nil str.-) contents))

(defn str-^-uq-- s contents
  (c s /list (c s /istring-nil str.^)
  /c s /list (c s /istring-nil str.uq)
  /c s /list (c s /istring-nil str.-) contents))

(defn scope-get string scope
  (cast scope scope unique-ns def-ns qualify
    err.\;qq[Expected a scope that was a scope]
  /scope (ns-get string unique-ns) def-ns qualify))

(defn scope-spread-later scope list combine-later then
  (case list
    
    nil (c-later then /nil)
    
    cons first rest
    (c combine-later (scope-get str.first scope) first /fn first
    /scope-spread-later (scope-get str.rest scope) rest
      combine-later
    /fn rest
    /c then /cons first rest)
    
    err.\;qq[Expected a list that was a nil or a cons]))

(defn istring-scope-spread-later scope istring combine-later then
  (case istring
    
    istring-nil - (c-later then istring)
    
    istring-cons prefix interpolation rest
    (c combine-later (scope-get str.first scope) interpolation
    /fn interpolation
    /istring-scope-spread-later (scope-get str.rest scope) rest
      combine-later
    /fn rest
    /c then /istring-cons prefix interpolation rest)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(defn istring-map istring func
  (case istring
    
    istring-nil - istring
    
    istring-cons prefix interpolation rest
    (istring-cons prefix (c func interpolation)
    /istring-map rest func)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(def-macro tvary home-scope caller-scope my-stx-details args then
  (cast caller-scope
    scope caller-unique-ns caller-def-ns caller-qualify
    err.\;qq[Internal error]
  /join-effects procure-claim.caller-unique-ns
  /cast args cons istring args
    err.\;qq[Called tvary with fewer than one argument]
  /cast args nil
    err.\;qq[Called tvary with more than one argument]
  /cast istring stx - istring
    err.\;qq[Expected an istring that was a stx]
  /parse-chops-later istring /fn parse-chops-result
  /cast parse-chops-result
    parse-chops-result closed-stack chops opened-stack
    err.\;qq[Internal error]
  /cast closed-stack nil
    err.\;qq[Unmatched \>]
  /cast opened-stack nil
    err.\;qq[Unmatched \<]
  /istring-scope-spread-later (scope-get str.subexprs caller-scope)
    chops
    (fn scope interpolation then
      (case interpolation foreign expr
        (compile-expression-later scope expr then)
        (chops-macroexpand-later scope interpolation then)))
  /fn chops
  /basic-pure-macro home-scope (scope-get str.body caller-scope)
    my-stx-details
    then
  /fn unique-ns s mac
  /c s /c mac str.pass-to /list (c s /c mac str.tvary-then /list)
  /c s /c mac str.qdo /list/str-^-qq-- s
  /c s /c mac str.tvary-later-done /list
  /c s /c mac str.istr /list
  /c s /istring-map chops /fn cexpr
    (str-^-uq-- s /c s /foreign/obtain-directly cexpr)))

(defn compile-tvary-cycler-later
  home-scope caller-scope chops cycler-name then
  
  (cast home-scope scope home-unique-ns home-def-ns home-qualify
    err.\;qq[Expected a home-scope that was a scope]
  /cast caller-scope
    scope caller-unique-ns caller-def-ns caller-qualify
    err.\;qq[Expected a caller-scope that was a scope]
  /join-effects procure-claim.caller-unique-ns
  /let s (fn s-expr /stx (trivial-stx-details/nil) s-expr)
  /let mac
    (fn mode str rest
      (cons
        (c s /foreign/obtain-directly/getdef-get mode
        /procure-macro-implementation-getdef home-def-ns
        /c home-qualify /name-of/dexable (dex-string/nil) str)
        rest))
  /chops-split-and-trim-later chops /fn chops-list
  /scope-spread-later (scope-get str.list caller-scope) chops-list
    (fn scope chops then
      (istring-scope-spread-later (scope-get str.subexprs scope) chops
        (fn scope interpolation then
          (case interpolation foreign expr
            (compile-expression-later scope expr then)
            (chops-macroexpand-later scope interpolation then)))
      /fn chops
      /get-mode/fn mode
      /compile-expression-later (scope-get str.body scope)
        (c s /c mac mode str.pass-to /list
          (c s /c mac mode str.tvary-then /list)
        /c s /c mac mode str.qdo /list/str-^-qq-- s
        /c s /c mac mode str.tvary-later-done /list
        /c s /c mac mode str.istr /list
        /c s /istring-map chops /fn cexpr
          (str-^-uq-- s /c s /foreign/obtain-directly cexpr))
      /fn cexpr
      /c then /c s /foreign/obtain-directly cexpr))
  /fn elems
  /get-mode/fn mode
  /compile-expression-later (scope-get str.body caller-scope)
    (c s /c mac mode cycler-name /list
      (c s /c mac mode str.uniq-name /list)
    /c s /c mac mode str.list elems)
    then))

(def-chops-macro cycle home-scope caller-scope chops then
  (compile-tvary-cycler-later home-scope caller-scope chops
    str.tvary-cycling then))

(def-chops-macro proceed home-scope caller-scope chops then
  (compile-tvary-cycler-later home-scope caller-scope chops
    str.tvary-proceeding then))

(defn compile-tvary-constant-later
  home-scope caller-scope chops err-fn constant then
  
  (chops-trim-later chops /fn trimmed
  /cast trimmed istring-nil trimmed (c err-fn /nil)
  /cast (string-metacompare trimmed str.\;qq[]) nil (c err-fn /nil)
  /cast home-scope scope home-unique-ns home-def-ns home-qualify
    err.\;qq[Expected a home-scope that was a scope]
  /cast caller-scope
    scope caller-unique-ns caller-def-ns caller-qualify
    err.\;qq[Expected a caller-scope that was a scope]
  /join-effects procure-claim.caller-unique-ns
  /let s (fn s-expr /stx (trivial-stx-details/nil) s-expr)
  /let mac
    (fn mode str rest
      (cons
        (c s /foreign/obtain-directly/getdef-get mode
        /procure-macro-implementation-getdef home-def-ns
        /c home-qualify /name-of/dexable (dex-string/nil) str)
        rest))
  /get-mode/fn mode
  /compile-expression-later (scope-get str.body caller-scope)
    (c s /c mac mode str.tvary-done /list
    /c s /c mac mode str.str /list
    /c s /istring-nil constant)
    then))

\= The Chops macro call `[']` becomes a `tvary` of the
\= single-character string "|". The point is to allow "|" to be part
\= of the text instead of being treated as a divider.
(def-chops-macro \;qq['] home-scope caller-scope chops then
  (compile-tvary-constant-later home-scope caller-scope chops
    (fn -
      err.\;qq[Called the | Chops macro without an empty body])
    str.\;qq[|]
    then))

\= The Chops macro call `[:]` becomes a `tvary` of the empty string.
\= The point is to act as a buffer so that the nearby whitespace on
\= one side doesn't get trimmed.
(def-chops-macro \;qq[:] home-scope caller-scope chops then
  (compile-tvary-constant-later home-scope caller-scope chops
    (fn -
      err.\;qq[Called the : Chops macro without an empty body])
    str.\;qq[]
    then))

\= The Chops macro calls `[<]` becomes a `tvary` of the
\= single-character string "[", and likewise, `[>]` corresponds to
\= "]".
(def-chops-macro \;qq[<] home-scope caller-scope chops then
  (compile-tvary-constant-later home-scope caller-scope chops
    (fn -
      err.\;qq[Called the < Chops macro without an empty body])
    str.\;qq[\<]
    then))
(def-chops-macro \;qq[>] home-scope caller-scope chops then
  (compile-tvary-constant-later home-scope caller-scope chops
    (fn -
      err.\;qq[Called the < Chops macro without an empty body])
    str.\;qq[\>]
    then))

(def-chops-macro \;qq[] home-scope caller-scope chops then
  (basic-pure-macro home-scope caller-scope (trivial-stx-details/nil)
    then
  /fn unique-ns s mac
  /c s /c mac str.tvary /list
  /c s /istring-cons str.\;qq[]
    (c s /c mac str.tvary-done /list
    /c s /c mac str.str /list/c s /istring-nil str.\;qq[\<])
  /istring-cons str.\;qq[]
    (c s /c mac str.tvary /list /c s chops)
  /istring-cons str.\;qq[]
    (c s /c mac str.tvary-done /list
    /c s /c mac str.str /list/c s /istring-nil str.\;qq[\>])
  /istring-nil str.\;qq[]))
