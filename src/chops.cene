\= chops.cene (part of Cene Scaffold)
\= Copyright 2016 Ross Angle. Released under the MIT License.

\= TODO: See if we should factor this file out into a separate
\= codebase.

\= TODO: Test this file. We're not even loading it yet, let alone
\= using it.

\= TODO: Use the chops parsers to create a convenient syntax for text
\= variations, perhaps like this:
\=
\= tvary.\;qq[
\=   The clock struck [cycle twelve|three|six|nine]. The mouse
\=   [proceed ran up the clock|ran down the clock|was not impressed].]


(defn regex-or a b
  (regex-if a (regex-empty/nil) b))

(defn regex-seq a b
  (regex-if a b /regex-give-up/nil))

(defn regex-not regex
  (regex-if regex (regex-give-up/nil) (regex-empty/nil)))

(defn regex-lookahead regex
  (regex-not/regex-not regex))

\= TODO: See if we'll use these.
(defn unicode-scalar string
  (string-get-unicode-scalar string /int-zero/nil))
(defn regex-range a b
  (regex-one-in-range unicode-scalar.a unicode-scalar.b))

(defn regex-match-later regex string start then
  (optimize-regex-later regex /fn optimized-regex
  /optimized-regex-match-later
    optimized-regex string start string-length.string then))


(defn string-cut-both-later string i then
  (string-cut-later string (int-zero/nil) i /fn before
  /string-cut-later string i string-length.string /fn after
  /c then before after))


(defn istring-first-string istring
  (case istring
    istring-nil string string
    istring-cons prefix interpolation rest prefix
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(defn istring-replace-first-string istring new-string
  (case istring
    
    istring-nil string istring-nil.new-string
    
    istring-cons prefix interpolation rest
    (istring-cons new-string interpolation rest)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))


(defn int-plus a b
  (call-fuse (fuse-int-by-plus/nil) a b))


(def-struct parse-chops-result closed-stack chops opened-stack)

\= This parses an istring to match its `[` and `]` brackets. It
\= asynchronously results in a list (from left to right) of nested
\= interpolated strings that have been closed by unmatched `]`,
\= another nested interpolated string, and a list (from left to right)
\= of nested interpolated strings that have been opened by unmatched
\= `[`. Interpolations in the original string are wrapped in
\= `(foreign ...)` so that they're distinguishable from bracket
\= nesting.
\=
(defn parse-chops-later istring then
  (let string istring-first-string.istring
  /regex-match-later
    (regex-until (regex-one/nil)
    /regex-lookahead/regex-one-in-string str.\;qq[\<`\>])
    string
    (int-zero/nil)
  /fn regex-result
  /case regex-result
    
    regex-result-passed-end
    (cast istring istring-cons prefix interpolation rest
      (c then /parse-chops-result (list) istring (list))
    /parse-chops-later rest /fn parse-chops-result
    /c then
    /cast parse-chops-result
      parse-chops-result closed-stack chops opened-stack
      err.\;qq[Internal error]
    /cast closed-stack cons leftmost-closed rest-closed
      (parse-chops-result
        (list)
        (istring-cons prefix foreign.interpolation chops)
        opened-stack)
    /parse-chops-result
      (cons
        (istring-cons prefix foreign.interpolation leftmost-closed)
        rest-closed)
      chops
      opened-stack)
    
    regex-result-matched stop
    (string-cut-both-later string stop /fn before after
    /string-cut-both-later after (int-one/nil) /fn during after
    /parse-chops-later (istring-replace-first-string istring after)
    /fn parse-chops-result
    /c then
    /cast parse-chops-result
      parse-chops-result closed-stack chops opened-stack
      err.\;qq[Internal error]
    /case (call-dex (dex-string/nil) during str.\;qq[\>]) yep -
      (parse-chops-result
        (cons istring-nil.before closed-stack)
        chops
        opened-stack)
    /cast closed-stack cons leftmost-closed rest-closed
      (parse-chops-result
        (list)
        istring-nil.before
        (cons chops opened-stack))
    /cast rest-closed cons leftmost-closed-2 rest-closed
      (parse-chops-result
        (list)
        (istring-cons before leftmost-closed chops)
        opened-stack)
    /parse-chops-result
      (cons (istring-cons before leftmost-closed leftmost-closed-2)
        rest-closed)
      chops
      opened-stack)
    
    regex-result-failed
    err.\;qq[Internal error]
    
    err.\;qq[Internal error]))

(def-struct chops-macro-call macro-name-string body-istring)

\= This parses an interpolated string to produce a macro call
\= consisting of a string as the macro name and an interpolated string
\= as the macro body. The macro name is obtained by finding zero or
\= more characters at the start of the string other than space, tab,
\= carriage return, newline, and `:`. The macro body is obtained by
\= removing the macro name and the `:`, or by removing the macro name
\= and left-trimming the remainder of one or more space, tab, carriage
\= return, and newline characters, whichever case applies.
\=
(defn parse-chops-macro-call-later istring then
  (let string istring-first-string.istring
  /let regex-colon (regex-from-string str.\;qq[:])
  /let regex-whitespace (regex-one-in-string str.\;qq[\s`\t`\r`\n])
  /regex-match-later
    (regex-until (regex-one/nil)
    /regex-lookahead/regex-or regex-colon regex-whitespace)
    string
    (int-zero/nil)
  /fn regex-result
  /case regex-result
    
    regex-result-passed-end
    (case istring
      
      istring-nil string
      (c then /chops-macro-call string /istring-nil str.\;qq[])
      
      istring-cons prefix interpolation rest
      (c then /chops-macro-call prefix
      /istring-cons str.\;qq[] interpolation rest)
      
      err.\;qq[Internal error])
    
    regex-result-matched stop
    (string-cut-both-later string stop /fn before after
    /regex-match-later
      (regex-or regex-colon
      /regex-seq regex-whitespace
      /regex-until (regex-one/nil)
      /regex-not regex-whitespace)
      after
      (int-zero/nil)
    /fn regex-result
    /cast regex-result regex-result-matched next-stop
      err.\;qq[Internal error]
    /string-cut-later after next-stop string-length.after /fn after
    /c then /chops-macro-call before
    /istring-replace-first-string istring after)
    
    regex-result-failed
    err.\;qq[Internal error]
    
    err.\;qq[Internal error]))

(defn string-ltrim-later string regex then
  (regex-match-later (regex-while regex /regex-empty/nil) string
    (int-zero/nil)
  /fn regex-result
  /case regex-result
    
    regex-result-matched stop
    (string-cut-later string stop string-length.string then)
    
    regex-result-passed-end
    err.\;qq[Expected a regex that consumed only one character]
    
    regex-result-failed
    err.\;qq[Internal error]
    
    err.\;qq[Internal error]))

(defn istring-ltrim-later istring regex then
  (string-ltrim-later istring-first-string.istring regex /fn string
  /c then /istring-replace-first-string istring string))

(defn string-rtrim-later string regex then
  (let get-next-stop-later
    (fn i regex then
      (regex-match-later regex string i /fn regex-result
      /case regex-result
        
        regex-result-matched stop
        (c then stop)
        
        regex-result-passed-end
        err.\;qq[Expected a regex that consumed only one character]
        
        regex-result-failed
        err.\;qq[Internal error]
        
        err.\;qq[Internal error]))
  /let loop
    (fix/fn loop i
      (c get-next-stop-later i
        (regex-until (regex-one/nil) /regex-lookahead regex)
      /fn i2
      /c get-next-stop-later i2 (regex-while regex /regex-empty/nil)
      /fn i3
      /case (int-compare i3 /string-length string) nil
        (string-cut-later string (int-zero/nil) i2 then)
      /c loop i3))
  /c loop /int-zero/nil))

(defn istring-rtrim-later istring regex then
  (case istring
    
    istring-nil string
    (string-rtrim-later string regex /fn string
    /c then /istring-nil string)
    
    istring-cons prefix interpolation rest
    (istring-rtrim-later rest regex /fn rest
    /c then /istring-cons prefix interpolation rest)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(defn istring-trim-later istring regex then
  (istring-ltrim-later istring regex /fn istring
  /istring-rtrim-later istring regex then))

(defn string-split-later string regex then
  (let loop
    (fix/fn loop rev-results i
      (regex-match-later
        (regex-until (regex-one/nil) /regex-lookahead regex)
        string
        i
      /fn regex-result
      /case regex-result
        
        regex-result-matched stop
        (string-cut-later string i stop /fn result
        /regex-match-later regex string stop /fn regex-result
        /cast regex-result regex-result-matched stop
          err.\;qq[Internal error]
        /c loop (cons result rev-results) stop)
        
        regex-result-passed-end
        (string-cut-later string i string-length.string /fn result
        /c then /rev/cons result rev-results)
        
        regex-result-failed
        err.\;qq[Internal error]
        
        err.\;qq[Internal error]))
  /c loop (list) /int-zero/nil))

(defn istring-split-later istring regex then
  (case istring
    
    istring-nil string
    (string-split-later string regex /fn strings
    /c then /map strings /fn string istring-nil.string)
    
    istring-cons prefix interpolation rest
    (string-split-later prefix regex /fn prefix-strings
    /istring-split-later rest regex /fn rest-istrings
    /cast rev.prefix-strings
      cons last-prefix-string rev-prefix-strings
      err.\;qq[Internal error]
    /cast rest-istrings cons first-rest-istring rest-istrings
      err.\;qq[Internal error]
    /c then /rev-append
      (map rev-prefix-strings /fn string istring-nil.string)
    /cons
      (istring-cons
        last-prefix-string interpolation first-rest-istring)
      rest-istrings)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(defn chops-split-and-trim-later istring then
  (istring-split-later istring (regex-from-string str.\;qq[|])
  /fn istrings
  /map-later istrings
    (fn istring then
      (istring-trim-later (regex-one-in-string str.\;qq[\s`\t`\r`\n])
        then))
    then))

(def-struct chops-macro-occurrence name)

(def-struct chops-macro-ns)

(defn procure-sub-ns name ns
  (proj1 yep /table-get name
  /procure-sub-ns-table (table-shadow name (yep/nil) /table-empty/nil)
    ns))

(defn getdef-get mode getdef
  (cast getdef getdef get def
    err.\;qq[Expected a getdef that was a getdef]
  /c get mode))

(defn getdef-def-val getdef val
  (cast getdef getdef get def
    err.\;qq[Expected a getdef that was a getdef]
  /c def (dex-give-up/nil) val))

(defn chops-macro-getdef macro-name-string scope
  (cast scope scope unique-ns def-ns qualify
    err.\;qq[Expected a scope that was a scope]
  /procure-contributed-element-getdef
    (name-of/dexable (dex-string/nil) str.\;qq[yep])
  /procure-sub-ns
    (c qualify
    /name-of/dexable (dex-struct chops-macro-occurrence /dex-name/nil)
    /chops-macro-occurrence
    /name-of/dexable (dex-string/nil) macro-name-string)
  /procure-sub-ns
    (name-of/dexable dex-struct.chops-macro-ns /chops-macro-ns)
    def-ns))

(defn chops-macroexpand-later scope istring then
  (parse-chops-macro-call-later istring /fn call
  /cast call chops-macro-call macro body
    err.\;qq[Internal error]
  /get-mode/fn mode
  /c (getdef-get mode /chops-macro-getdef macro scope)
    scope body then))

(def-macro def-chops-macro
  home-scope caller-scope my-stx-details args then
  
  (cast caller-scope
    scope caller-unique-ns caller-def-ns caller-qualify
    err.\;qq[Internal error]
  /join-effects procure-claim.caller-unique-ns
  /let subscope
    (fn string
      (scope (ns-get string caller-unique-ns) caller-def-ns
        caller-qualify))
  /cast args cons macro-name fn-body
    err.\;qq[Called def-chops-macro with fewer than one argument]
  \= TODO: Support more than just string names here.
  /cast macro-name istring-nil macro-name-string
    err.\;qq[Called def-chops-macro with a non-string macro name]
  /basic-nil-macro
    home-scope (c subscope str.body) my-stx-details then
  /fn unique-ns s mac
  /compile-expression-later (c subscope str.compile-fn)
    (c s /c mac str.fn fn-body)
  /fn func
  /getdef-def-val (chops-macro-getdef macro-name-string caller-scope)
  /c eval-cexpr.func /c subscope str.home))


(defn str-^-qq-- s contents
  (c s /list (c s /istring-nil str.^)
  /c s /list (c s /istring-nil str.qq)
  /c s /list (c s /istring-nil str.-) contents))

(defn str-^-uq-- s contents
  (c s /list (c s /istring-nil str.^)
  /c s /list (c s /istring-nil str.uq)
  /c s /list (c s /istring-nil str.-) contents))

(defn istring-unique-ns-spread-later
  unique-ns istring combine-later then
  
  (case istring
    
    istring-nil - (c-later then istring)
    
    istring-cons prefix interpolation rest
    (c combine-later (ns-get str.first unique-ns) interpolation
    /fn interpolation
    /istring-unique-ns-spread-later (ns-get str.rest unique-ns) rest
      combine-later
    /fn rest
    /c then /istring-cons prefix interpolation rest)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(defn istring-map istring func
  (case istring
    
    istring-nil - istring
    
    istring-cons prefix interpolation rest
    (istring-cons prefix (c func interpolation)
    /istring-map rest func)
    
    err.\;qq[
      Expected an istring that was an istring-nil or an
      istring-cons]))

(def-macro tvary home-scope caller-scope my-stx-details args then
  (cast caller-scope
    scope caller-unique-ns caller-def-ns caller-qualify
    err.\;qq[Internal error]
  /join-effects procure-claim.caller-unique-ns
  /cast args cons istring args
    err.\;qq[Called tvary with fewer than one argument]
  /cast args nil
    err.\;qq[Called tvary with more than one argument]
  /cast istring stx - istring
    err.\;qq[Expected an istring that was a stx]
  /parse-chops-later istring /fn parse-chops-result
  /cast parse-chops-result
    parse-chops-result closed-stack chops opened-stack
    err.\;qq[Internal error]
  /cast closed-stack nil
    err.\;qq[Unmatched \>]
  /cast opened-stack nil
    err.\;qq[Unmatched \<]
  /istring-unique-ns-spread-later
    (ns-get str.subexprs caller-unique-ns)
    chops
    (fn unique-ns interpolation then
      (let scope (scope unique-ns caller-def-ns caller-qualify)
      /case interpolation foreign expr
        (compile-expression-later scope expr then)
        (chops-macroexpand-later scope interpolation then)))
  /fn chops
  /basic-pure-macro home-scope
    (scope (ns-get str.body caller-unique-ns) caller-def-ns
      caller-qualify)
    my-stx-details
    then
  /fn unique-ns s mac
  /c s /c mac str.pass-to /list (c s /c mac str.tvary-then /list)
  /c s /c mac str.qdo /list/str-^-qq-- s
  /c s /c mac str.tvary-later-done /list
  /c s /c mac str.istr /list
  /c s /istring-map chops /fn cexpr
    (str-^-uq-- s /c s /foreign/obtain-directly cexpr)))
